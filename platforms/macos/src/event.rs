// Copyright 2022 The AccessKit Authors. All rights reserved.
// Licensed under the Apache License, Version 2.0 (found in
// the LICENSE-APACHE file) or the MIT license (found in
// the LICENSE-MIT file), at your option.

use accesskit::NodeId;
use accesskit_consumer::{DetachedNode, FilterResult, Node, TreeChangeHandler, TreeState};
use objc2::foundation::NSString;
use std::rc::Rc;

use crate::{
    appkit::*,
    context::Context,
    node::{filter, NodeWrapper},
};

// This type is designed to be safe to create on a non-main thread
// and send to the main thread. This ability isn't yet used though.
pub(crate) enum QueuedEvent {
    Generic {
        node_id: NodeId,
        notification: &'static NSString,
    },
    NodeDestroyed(NodeId),
}

impl QueuedEvent {
    fn raise(self, context: &Rc<Context>) {
        match self {
            Self::Generic {
                node_id,
                notification,
            } => {
                let platform_node = context.get_or_create_platform_node(node_id);
                unsafe { NSAccessibilityPostNotification(&platform_node, notification) };
            }
            Self::NodeDestroyed(node_id) => {
                if let Some(platform_node) = context.remove_platform_node(node_id) {
                    unsafe {
                        NSAccessibilityPostNotification(
                            &platform_node,
                            NSAccessibilityUIElementDestroyedNotification,
                        )
                    };
                }
            }
        }
    }
}

/// Events generated by a tree update.
#[must_use = "events must be explicitly raised"]
pub struct QueuedEvents {
    context: Rc<Context>,
    events: Vec<QueuedEvent>,
}

impl QueuedEvents {
    /// Raise all queued events synchronously.
    ///
    /// It is unknown whether accessibility methods on the view may be
    /// called while events are being raised. This means that any locks
    /// or runtime borrows required to access the adapter must not
    /// be held while this method is called.
    pub fn raise(self) {
        for event in self.events {
            event.raise(&self.context);
        }
    }
}

pub(crate) struct EventGenerator {
    context: Rc<Context>,
    events: Vec<QueuedEvent>,
}

impl EventGenerator {
    pub(crate) fn new(context: Rc<Context>) -> Self {
        Self {
            context,
            events: Vec::new(),
        }
    }

    pub(crate) fn into_result(self) -> QueuedEvents {
        QueuedEvents {
            context: self.context,
            events: self.events,
        }
    }
}

impl TreeChangeHandler for EventGenerator {
    fn node_added(&mut self, _node: &Node) {
        // TODO: text changes, live regions
    }

    fn node_updated(&mut self, old_node: &DetachedNode, new_node: &Node) {
        // TODO: text changes, live regions
        if filter(new_node) != FilterResult::Include {
            return;
        }
        let node_id = new_node.id();
        let old_wrapper = NodeWrapper::DetachedNode(old_node);
        let new_wrapper = NodeWrapper::Node(new_node);
        if old_wrapper.title() != new_wrapper.title() {
            self.events.push(QueuedEvent::Generic {
                node_id,
                notification: unsafe { NSAccessibilityTitleChangedNotification },
            });
        }
        if old_wrapper.value() != new_wrapper.value() {
            self.events.push(QueuedEvent::Generic {
                node_id,
                notification: unsafe { NSAccessibilityValueChangedNotification },
            });
        }
    }

    fn focus_moved(&mut self, _old_node: Option<&DetachedNode>, new_node: Option<&Node>) {
        if let Some(new_node) = new_node {
            if filter(new_node) != FilterResult::Include {
                return;
            }
            self.events.push(QueuedEvent::Generic {
                node_id: new_node.id(),
                notification: unsafe { NSAccessibilityFocusedUIElementChangedNotification },
            });
        }
    }

    fn node_removed(&mut self, node: &DetachedNode, _current_state: &TreeState) {
        // TODO: text changes
        self.events.push(QueuedEvent::NodeDestroyed(node.id()));
    }
}
